name: Goal Tracker CI/CD

on:
  push:
    branches: [ main, develop, 'feature/*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      replicas:
        description: 'Number of replicas'
        required: false
        default: '2'
        type: string

env:
  REGISTRY: us-docker.pkg.dev
  IMAGE_NAME: ${{ secrets.GCP_PROJECT_ID }}
  REPOSITORY: gcr.io

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
        
    - name: Run backend tests
      run: |
        cd backend
        chmod +x ./mvnw
        ./mvnw clean test
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci
        
    - name: Build frontend
      run: |
        cd frontend
        npm run build
        
    - name: Run frontend tests
      run: |
        cd frontend
        npm run test

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        
    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        version: 'latest'
        
    - name: Configure Docker for Artifact Registry
      run: gcloud auth configure-docker us-docker.pkg.dev
      
    - name: Build and push backend image
      run: |
        cd backend
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/backend:${{ github.sha }} .
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/backend:latest .
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/backend:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/backend:latest
        
    - name: Build and push frontend image
      run: |
        cd frontend
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/frontend:${{ github.sha }} .
        docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/frontend:latest .
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/frontend:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/frontend:latest
        
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
        
    - name: Install gke-gcloud-auth-plugin
      run: |
        gcloud components install gke-gcloud-auth-plugin
        echo 'export USE_GKE_GCLOUD_AUTH_PLUGIN=True' >> $GITHUB_ENV
        
    - name: Configure kubectl for GKE
      run: |
        gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} --zone ${{ secrets.GKE_ZONE }} --project ${{ secrets.GCP_PROJECT_ID }}
        
    - name: Determine deployment environment
      id: env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          echo "replicas=${{ github.event.inputs.replicas }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "replicas=1" >> $GITHUB_OUTPUT
        elif [ "${{ github.ref }}" = "refs/heads/develop" ] || [[ "${{ github.ref }}" == refs/heads/feature/* ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "replicas=1" >> $GITHUB_OUTPUT
        else
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "replicas=1" >> $GITHUB_OUTPUT
        fi
        
    - name: Create namespaces
      run: |
        kubectl apply -f k8s/namespaces.yaml
        
    - name: Deploy to ${{ steps.env.outputs.environment }}
      run: |
        ENV="${{ steps.env.outputs.environment }}"
        REPLICAS="${{ steps.env.outputs.replicas }}"
        
        echo "üöÄ Deploying to $ENV namespace with $REPLICAS replicas..."
        
        # Deploy backend
        kubectl apply -f k8s/backend-deployment.yaml -n $ENV
        kubectl set image deployment/backend backend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/backend:${{ github.sha }} -n $ENV
        sleep 5
        kubectl scale deployment backend --replicas=$REPLICAS -n $ENV
        
        # Deploy frontend
        kubectl apply -f k8s/frontend-deployment.yaml -n $ENV
        kubectl set image deployment/goal-tracker-frontend frontend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/${{ env.REPOSITORY }}/frontend:${{ github.sha }} -n $ENV
        kubectl scale deployment goal-tracker-frontend --replicas=$REPLICAS -n $ENV
        
        # Wait for rollout
        kubectl rollout status deployment/backend -n $ENV --timeout=300s
        
        # Check frontend deployment with debugging
        echo "üîç Checking frontend deployment..."
        kubectl get pods -n $ENV -l app=goal-tracker-frontend
        kubectl describe pods -n $ENV -l app=goal-tracker-frontend | tail -20
        
        # Check frontend container logs
        echo "üìã Frontend container logs:"
        kubectl logs -n $ENV -l app=goal-tracker-frontend --tail=20 || echo "No logs available yet"
        
        # Wait a bit for container to start
        echo "‚è≥ Waiting for frontend container to start..."
        sleep 15
        kubectl get pods -n $ENV -l app=goal-tracker-frontend
        
        # Get detailed pod information
        echo "üîç Detailed pod status:"
        kubectl describe pods -n $ENV -l app=goal-tracker-frontend
        
        # Try to get logs again
        echo "üìã Frontend container logs (after wait):"
        kubectl logs -n $ENV -l app=goal-tracker-frontend --tail=20 || echo "Still no logs available"
        
        # Get backend logs too
        echo "üìã Backend container logs:"
        kubectl logs -n $ENV -l app=backend --tail=20 || echo "No backend logs available"
        
        # Check if there are any events
        echo "üìÖ Recent events:"
        kubectl get events -n $ENV --sort-by='.lastTimestamp' | tail -10
        
        kubectl rollout status deployment/goal-tracker-frontend -n $ENV --timeout=300s
        
        echo "‚úÖ Deployment to $ENV complete!"

    - name: Get deployment URLs
      run: |
        ENV="${{ steps.env.outputs.environment }}"
        echo "üîó Getting URLs for $ENV environment..."
        
        # Get backend service info
        echo "=== Backend Service ==="
        kubectl get service backend-service -n $ENV || echo "Backend service not found"
        
        # Get frontend service info
        echo "=== Frontend Service ==="
        kubectl get service goal-tracker-frontend-service -n $ENV || echo "Frontend service not found"
        
        # Get external IP for frontend
        EXTERNAL_IP=$(kubectl get service goal-tracker-frontend-service -n $ENV -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
        if [ -n "$EXTERNAL_IP" ]; then
          echo "üåê Frontend URL: http://$EXTERNAL_IP"
        else
          echo "‚è≥ External IP not ready yet. Check with: kubectl get services -n $ENV"
        fi
        
    - name: Health check
      run: |
        ENV="${{ steps.env.outputs.environment }}"
        echo "üîç Checking deployment status..."
        kubectl get pods -n $ENV
        
    - name: Cleanup old deployments
      if: steps.env.outputs.environment == 'development'
      run: |
        echo "üßπ Cleaning up old development deployments..."
        # Keep only the last 3 deployments
        kubectl get deployments -n development --sort-by=.metadata.creationTimestamp -o name | head -n -3 | xargs -r kubectl delete -n development

  smoke-test:
    name: k6 smoke test
    needs: build-and-deploy
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify k6 script path
        run: |
          echo "Workspace: ${{ github.workspace }}"
          ls -la "${{ github.workspace }}/tests/k6" || true

      - name: Run k6 smoke test via Docker
        env:
          BASE_URL: http://34.134.153.6
        run: |
          echo "Running k6 smoke test against $BASE_URL"
          docker run --rm -v "${{ github.workspace }}/tests/k6:/scripts" grafana/k6 run /scripts/smoke.js -e BASE_URL=$BASE_URL